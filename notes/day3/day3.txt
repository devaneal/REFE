3. DEP, ROP, and ret2libc
    * mitigations
    * dep, ret2libc, x86 vs x86-64
    * aslr, rop given leak

==== Mitigations ====
There are several mitigations in place to prevent the type of exploit we saw
yesterday. The big three, all of which are enabled by default:

* DEP/NX/W^X
Data Execution Prevention / Non-eXecutable stack / Write xor eXecute - all
mapped memory is either writable or executable, but never both

* ASLR
Address Space Layout Randomization - stack, heap, and share library locations
are randomized at runtime

* Stack Canaries
Places a random token in each stack frame separating local variables from the
saved base pointer and return address

And the runner-ups, which must be specified at compile-time:

* (Full) RELRO
RElocation Read-Only - makes the got read-only by resolving all shared library
code when the program is first loaded; programs have partial RELRO by default,
but it offers very little exploit protection

* PIC/PIE - Position Independent Code/ Executables - an extension of ASLR which
allows the location of program code to be randomized as well; PIC is for shared
library code while PIE is for executables

* Fortify Source
Adds additional checks at compile and/or runtime, but may violate code
conformity

Something to be aware of: most functions to read input will stop when they
encounter a whitespace character. Keep this in mind when writing exploits, and
check "man ascii" when in doubt.

==== DEP and ROP ====
Return-Oriented Programming (ROP) is an exploit technique to bypass DEP. Rather
than inject shellcode into the program, we overwrite the return address with one
or more addresses of snippets of code (gadgets) we want to execute. As long as
each snippet ends with a ret instruction, each one will be executed.

** ret2libc
* view source, mention system()
* mention DEP (checksec) and static linking (file)

Our goal is to call system("/bin/sh") to spawn a shell. Both system() and
"/bin/sh" are located in the binary, so we need to find their locations.
We also find a "pop ret" gadget so that we can pass "/bin/sh" as the argument.

* get "pop rdi; ret" address with ROPgadget
* get "/bin/sh" address with strings -tx
* get system() address with readelf --syms
* let students spawn the shell

+----------------+
|  pop rdi; ret  |
+----------------+
|   "/bin/sh"    |
+----------------+
|     system     |
+----------------+

This particular ROP technique is called return-to-libc (ret2libc) since we spawn
the shell by returning to a libc function.

** ret2libc_32
* view source
* explain the difference in calling convention and the modified plan
* let the students spawn the shell

+----------------+
|     system     |
+----------------+
|    padding     |
+----------------+
|   "/bin/sh"    |
+----------------+

Chaining rop gadgets is different in x86 vs x86-64. An x86 rop chain has the
form

+----------------+
|   function 1   |
+----------------+
|  pop-pop-ret   |
+----------------+
|     arg 1      |
+----------------+
|     arg 2      |
+----------------+
        + 
+----------------+
|   function 2   |
+----------------+
| pop-pop-pop-ret|
+----------------+
|     arg 1      |
+----------------+
|     arg 2      |
+----------------+
|     arg 3      |
+----------------+
        +
+----------------+
|      ...       |
+----------------+

While an x86-64 rop chain has the form

+--------------------------------+
|     pop rdi; pop rsi; ret      |
+--------------------------------+
|            arg 1               |
+--------------------------------+
|            arg 2               |
+--------------------------------+
|          function 1            |
+--------------------------------+
               + 
+--------------------------------+
| pop rdi; pop rsi; pop rdx; ret |
+--------------------------------+
|            arg 1               |
+--------------------------------+
|            arg 2               |
+--------------------------------+
|            arg 3               |
+--------------------------------+
|          function 2            |
+--------------------------------+
               +
+--------------------------------+
|             ...                |
+--------------------------------+

==== ASLR ====
Although ASLR randomizes the locations of the stack, heap, and shared libraries,
each section is still loaded contiguously. This means that if you can leak a
single library address and you have a copy of the library, you can calculate the
locations of everything else in the library.

** use_leak
* view source code, point out leak
* show how to programmatically read the address with pwntools
* find puts and system offsets with readelf (suffix @@GLIBC_2.2.5)
* find "/bin/sh" offset with strings -tx
* let students spawn the shell
