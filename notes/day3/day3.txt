3. DEP, ROP, and ret2libc
    * mitigations
    * dep, ret2libc
    * aslr, rop given leak
    * got/plt, rop without leak

==== Mitigations ====
There are several mitigations in place to prevent the type of exploit we saw
yesterday. The big three, all of which are enabled by default:

* DEP/NX/W^X
Data Execution Prevention / Non-eXecutable stack / Write xor eXecute - all
mapped memory is either writable or executable, but never both

* ASLR
Address Space Layout Randomization - stack, heap, and share library locations
are randomized at runtime

* Stack Canaries
Places a random token in each stack frame separating local variables from the
saved base pointer and return address

And the runner-ups, which must be specified at compile-time:

* (Full) RELRO
RElocation Read-Only - makes the got read-only by resolving all shared library
code when the program is first loaded; programs have partial RELRO by default,
but it offers very little exploit protection

* PIC/PIE - Position Independent Code/ Executables - an extension of ASLR which
allows the location of program code to be randomized as well; PIC is for shared
library code while PIE is for executables

* Fortify Source
Adds additional checks at compile and/or runtime, but may violate code
conformity

==== DEP and ROP ====
Return-Oriented Programming (ROP) is an exploit technique to bypass DEP. Rather
than inject shellcode into the program, we overwrite the return address with one
or more addresses of snippets of code (gadgets) we want to execute. As long as
each snippet ends with a ret instruction, each one will be executed.

** ret2libc
* view source, mention system()
* mention DEP (checksec) and static linking (file)

Our goal is to call system("/bin/sh") to spawn a shell. Both system() and
"/bin/sh" are located in the binary, so we need to find their locations.
We also find a "pop ret" gadget so that we can pass "/bin/sh" as the argument.

* get "pop rdi; ret" address with ROPgadget
* get "/bin/sh" address with strings -tx
* get system() address with readelf --syms
* let students spawn the shell

+----------------+
|  pop rdi; ret  |
+----------------+
|   "/bin/sh"    |
+----------------+
|     system     |
+----------------+

This particular ROP technique is called return-to-libc (ret2libc) since we spawn
the shell by returning to a libc function.

==== ASLR ====
Although ASLR randomizes the locations of the stack, heap, and shared libraries,
each section is still loaded contiguously. This means that if you can leak a
single library address and you have a copy of the library, you can calculate the
locations of everything else in the library.

** use_leak
* view source code, point out leak
* show how to programmatically read the address with pwntools
* find puts and system offsets with readelf (suffix @@GLIBC_2.2.5)
* find "/bin/sh" offset with strings -tx
* let students spawn the shell

==== GOT and PLT ====
The plt is a list of code stubs, one for each shared library function and one
more to resolve them. Each stub for a shared library contains a jump into the
got followed by a section to prepare and jump to the resolver.

The got initially contains a bunch of pointers back into the plt, one for each
shared library function. They point at the sections which prepare and jump to
the resolver.

The resolver locates, or resolves, a shared library based on its arguments
(prepared by the plt), writes its location to the got, and calls the function.
Therefore subsequent function calls will not go through the resolver.

In order for this to work, the got must be writable. This makes it a prime
candidate target for exploitation.

** make_leak
* view source code (file and checksec), ask for exploitation suggestions
* explain the plan in detail:
  1) read() puts() address from the got
  2) return to main()
  3) ret2libc as before
* find puts@plt with objdump -d -j .plt (or pwndbg)
* find puts@got with readelf --relocs (or pwndbg)
* let students spawn the shell

+----------------+
|  pop rdi; ret  |
+----------------+
|    puts@got    |
+----------------+
|    puts@plt    |
+----------------+
|      main      |
+----------------+
